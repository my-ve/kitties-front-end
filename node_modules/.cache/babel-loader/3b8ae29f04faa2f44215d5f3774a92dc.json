{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { withTypeString } from \"../create/encodeTypes.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../types/index.js\"; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec']; // These are reserved and/or conflicts with built-in Codec definitions\n\nconst RESERVED = ['call', 'entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    return a === '*' || a === b || a.includes('*') && a.includes('_') && b.includes('_') && matchParts(a.split('_'), b.split('_'));\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(names) {\n  return names.map(([lookupIndex, name]) => [lookupIndex, !name || names.some(([oIndex, oName]) => name === oName && lookupIndex !== oIndex) ? null : name]);\n}\n\nfunction extractName(types, id, {\n  params,\n  path\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName];\n}\n\nfunction extractNames(registry, types) {\n  const dedup = removeDuplicateNames(types.map(({\n    id,\n    type\n  }) => extractName(types, id, type)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name], index) => {\n    if (name) {\n      // We set the name for this specific type\n      names[index] = name; // we map to the actual lookupIndex\n\n      types[name] = registry.createLookupType(lookupIndex);\n    }\n\n    return [names, types];\n  }, [{}, {}]);\n  registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(registry, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      // we set first since we will get into circular lookups along the way\n      _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n        type: this.registry.createLookupType(lookupIndex)\n      };\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex);\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const path = [...type.path];\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`Invalid type at index ${lookupIndex}: No handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace: path.join('::')\n  }, typeDef);\n}\n\nfunction _extractArray2(lookupIndex, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, () => `PortableRegistry: ${lookupIndex}: Only support for [Type; <length>], where length <= 256`);\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  if (path.length === 1 && path[0].eq('BTreeMap')) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(lookupIndex, params, fields) {\n  assert(params.length === 1 && fields.length === 1, () => `PortableRegistry: ${lookupIndex}: Set handling expects since param and single field`);\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, () => `PortableRegistry: ${lookupIndex}: Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)`);\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())).map((def, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, def))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}","map":{"version":3,"sources":["/home/spren/workspace/kitties-front-end/node_modules/@polkadot/types/generic/PortableRegistry.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isString","stringCamelCase","stringify","stringUpperFirst","Struct","withTypeString","getTypeDef","TypeDefInfo","PRIMITIVE_ALIAS","Char","Str","PRIMITIVE_PATHS","map","p","split","SETS","WRAPPERS","RESERVED","matchParts","first","second","every","a","index","b","toString","includes","getPrimitivePath","path","some","removeDuplicateNames","names","lookupIndex","name","oIndex","oName","extractName","types","id","params","toNumber","parts","toLowerCase","typeName","join","type","isSome","instanceType","unwrap","extractNames","registry","dedup","typesNew","reduce","createLookupType","register","_names","_typeDefs","_createSiDef","_getLookupId","_extract","_extractArray","_extractBitSequence","_extractCompact","_extractComposite","_extractCompositeSet","_extractFields","_extractFieldsAlias","_extractHistoric","_extractPrimitive","_extractPrimitivePath","_extractSequence","_extractTuple","_extractVariant","_extractVariantEnum","GenericPortableRegistry","constructor","value","_extractVariantEnum2","_extractVariant2","_extractTuple2","_extractSequence2","_extractPrimitivePath2","_extractPrimitive2","_extractHistoric2","_extractFieldsAlias2","_extractFields2","_extractCompositeSet2","_extractComposite2","_extractCompact2","_extractBitSequence2","_extractArray2","_extract2","_getLookupId2","_createSiDef2","writable","get","getSiType","lookupId","found","info","DoNotConstruct","lookupName","extracted","k","Plain","lookupNameRoot","typeDef","Enum","docs","Si","isLookupType","parseInt","replace","primType","def","isArray","asArray","isBitSequence","asBitSequence","isCompact","asCompact","isComposite","asComposite","isHistoricMetaCompat","asHistoricMetaCompat","isPrimitive","isSequence","asSequence","isTuple","asTuple","isVariant","asVariant","Error","error","message","d","namespace","len","VecFixed","sub","_","bitOrderType","bitStoreType","bitOrder","bitStore","Compact","fields","eq","BTreeMap","Set","createType","bitLength","variants","isStruct","isAllNamed","isAllUnnamed","isNone","Null","alias","Tuple","size","Map","nameField","nameOrig","set","displayName","isFromSi","typeStr","asPrimitive","Vec","ids","specialVariant","Option","Result","sort","cmp","desired"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { withTypeString } from \"../create/encodeTypes.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../types/index.js\"; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec']; // These are reserved and/or conflicts with built-in Codec definitions\n\nconst RESERVED = ['call', 'entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    return a === '*' || a === b || a.includes('*') && a.includes('_') && b.includes('_') && matchParts(a.split('_'), b.split('_'));\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(names) {\n  return names.map(([lookupIndex, name]) => [lookupIndex, !name || names.some(([oIndex, oName]) => name === oName && lookupIndex !== oIndex) ? null : name]);\n}\n\nfunction extractName(types, id, {\n  params,\n  path\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName];\n}\n\nfunction extractNames(registry, types) {\n  const dedup = removeDuplicateNames(types.map(({\n    id,\n    type\n  }) => extractName(types, id, type)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name], index) => {\n    if (name) {\n      // We set the name for this specific type\n      names[index] = name; // we map to the actual lookupIndex\n\n      types[name] = registry.createLookupType(lookupIndex);\n    }\n\n    return [names, types];\n  }, [{}, {}]);\n  registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(registry, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      // we set first since we will get into circular lookups along the way\n      _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n        type: this.registry.createLookupType(lookupIndex)\n      };\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex);\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const path = [...type.path];\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`Invalid type at index ${lookupIndex}: No handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace: path.join('::')\n  }, typeDef);\n}\n\nfunction _extractArray2(lookupIndex, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, () => `PortableRegistry: ${lookupIndex}: Only support for [Type; <length>], where length <= 256`);\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  if (path.length === 1 && path[0].eq('BTreeMap')) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(lookupIndex, params, fields) {\n  assert(params.length === 1 && fields.length === 1, () => `PortableRegistry: ${lookupIndex}: Set handling expects since param and single field`);\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, () => `PortableRegistry: ${lookupIndex}: Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)`);\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())).map((def, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, def))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}"]},"metadata":{},"sourceType":"module"}