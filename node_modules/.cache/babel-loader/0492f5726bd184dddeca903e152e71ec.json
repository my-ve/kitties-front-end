{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, compactAddLength, compactStripLength, isUndefined, stringCamelCase, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { Raw } from \"../../../codec/index.js\";\nimport { getHasher } from \"./getHasher.js\";\n/** @internal */\n\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  return u8aConcat(xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128), ...keys.map((type, index) => getHasher(hashers[index])(registry.createType(type.toString(), args[index]).toU8a())));\n}\n/** @internal */\n\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, provided in tuple format`);\n  assert(args.filter(a => !isUndefined(a)).length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n}\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    docs,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    docs,\n    fallback: registry.createType('Bytes'),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n}\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length < type.asNMap.hashers.length, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isDoubleMap) {\n        return new Raw(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [type.asDoubleMap.hasher], args));\n      } else if (type.isNMap) {\n        let keys = [...type.asNMap.keyVec];\n        let hashers = [...type.asNMap.hashers]; // pick the first n entries where n = args.length which is already verified above to be less that the full arguments.\n\n        keys = keys.slice(0, args.length);\n        hashers = hashers.slice(0, args.length);\n        return new Raw(registry, createKeyRaw(registry, itemFn, keys, hashers, args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isPlain ? options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [type.asMap.hasher], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [type.asDoubleMap.hasher, type.asDoubleMap.key2Hasher], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers, arg));\n\n  if (type.isMap || type.isDoubleMap || type.isNMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","compactAddLength","compactStripLength","isUndefined","stringCamelCase","stringLowerFirst","u8aConcat","u8aToU8a","xxhashAsU8a","Raw","getHasher","createKeyRaw","registry","itemFn","hashers","args","prefix","method","map","type","index","createType","toString","toU8a","createKey","section","Array","isArray","a","join","expandWithMeta","meta","_storageFn","storageFn","toJSON","storage","extendHeadMeta","docs","name","iterFn","outputType","isMap","asMap","isDoubleMap","asDoubleMap","key1","asNMap","keyVec","fallback","modifier","extendPrefixedMap","iterKey","isNMap","hasher","slice","createFunction","options","arg","isPlain","skipHashing","key2","key2Hasher","keyPrefix"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactStripLength, isUndefined, stringCamelCase, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { Raw } from \"../../../codec/index.js\";\nimport { getHasher } from \"./getHasher.js\";\n\n/** @internal */\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  return u8aConcat(xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128), ...keys.map((type, index) => getHasher(hashers[index])(registry.createType(type.toString(), args[index]).toU8a())));\n}\n/** @internal */\n\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, provided in tuple format`);\n  assert(args.filter(a => !isUndefined(a)).length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n}\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    docs,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    docs,\n    fallback: registry.createType('Bytes'),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n}\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length < type.asNMap.hashers.length, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isDoubleMap) {\n        return new Raw(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [type.asDoubleMap.hasher], args));\n      } else if (type.isNMap) {\n        let keys = [...type.asNMap.keyVec];\n        let hashers = [...type.asNMap.hashers]; // pick the first n entries where n = args.length which is already verified above to be less that the full arguments.\n\n        keys = keys.slice(0, args.length);\n        hashers = hashers.slice(0, args.length);\n        return new Raw(registry, createKeyRaw(registry, itemFn, keys, hashers, args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isPlain ? options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [type.asMap.hasher], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [type.asDoubleMap.hasher, type.asDoubleMap.key2Hasher], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers, arg));\n\n  if (type.isMap || type.isDoubleMap || type.isNMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"module"}